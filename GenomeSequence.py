import randomclass GenomeSequence:    def __init__(self, genome):        self.genome = genome        # execute createBreakpointlist when initializing        self.breakpointList, self.breakpointPairs = self.createBreakpointList(genome)    # Creates the initial breakpointlist    def createBreakpointList(self, genome):        # declare arrays that store indices that may be an i or a j        breakpointList = []        breakpointPairs = 0        for i in range(0, len(genome) - 1):            # check if breakpoint            if abs(genome[i] - genome[i + 1]) != 1:                breakpointPairs = breakpointPairs + 1                # specify what may be a possible i or j                if i > 0 and i < len(genome) - 1:                    breakpointList.append(i)                if i < len(genome) - 2:                    breakpointList.append(i + 1)        breakpointList = list(set(breakpointList))        # print("initial breakpointList: ", breakpointList)        return breakpointList, breakpointPairs    # updates a specific part of the breakpointlist    def UpdateBreakpointList(self, i, j):                # initializes empty list        newList = []        # updates point within a stip without edges        if j - i > 3:            # iterates over i + 1 till j - 1            for m in range(i + 1, j):                                # checks if m is not a breakpoint                if abs(self.genome[m] - self.genome[m - 1]) == 1 and abs(self.genome[m] - self.genome[m + 1]) == 1:                                        # checks if m is in list                    if m in self.breakpointList:                                                # removes m                        self.breakpointList.remove(m)                                # m a breakpoint                else:                                        # and checks if m is not already in list and within bounds                     if m not in self.breakpointList and m < 26 and m > 0 :                                                # appends m                         self.breakpointList.append(m)        # checks edges of strip that is reversed        for m in [i - 1, i, j, j + 1]:            # checks if breakpoint            if abs(self.genome[m - 1] - self.genome[m]) == 1:                # checks if m not outside changeable genome and if m in breakpointlist and not in newlist                if m < len(self.genome) - 1:                    if m in self.breakpointList and m not in newList:                        self.breakpointList.remove(m)                # checks if m - 1 should be removed from breakpointlist                if m - 1 > 0:                    if m - 1 in self.breakpointList and m - 1 not in newList:                                                if m - 2 >= 0 and abs(self.genome[m - 2] - self.genome[m - 1]) == 1:                            self.breakpointList.remove(m - 1)            # if not breakpoint            else:                                # appends m - 1 to breakpoint list and newlist                if m - 1 > 0:                    self.breakpointList.append(m - 1)                    newList.append(m - 1)                                # appends m to breakpointlist and newList                if m > 0 and m < len(self.genome) - 1:                    self.breakpointList.append(m)                    newList.append(m)            # checks if m + 1 is in genome            if m + 1 < len(self.genome):                # checks for breakpoint                if abs(self.genome[m] - self.genome[m + 1]) == 1:                                        # checks if m and m + 1 should be removed from breakpointlist                    if m in self.breakpointList and m not in newList:                        self.breakpointList.remove(m)                    if m + 1 in self.breakpointList and m + 1 not in newList:                        if m + 2 < len(self.genome) and abs(self.genome[m + 2] - self.genome[m + 1]) == 1:                            self.breakpointList.remove(m + 1)                                # breakpoint found                else:                                        # appends m + 1 to breakpointlist                    if m + 1 < len(self.genome) - 1:                        self.breakpointList.append(m + 1)                        newList.append(m + 1)                    # appends m to breakpointlist                    self.breakpointList.append(m)                    newList.append(m)        # removes doubles and sorts list        self.breakpointList = list(set(self.breakpointList))    # Calculates change in PHI and returns the number of breakpoint eliminated by the reversal (i,j) returns 0, 1, 2    def CalcDeltaPHI(self, i, j):        # define bools to check if breakpoints are eliminated        eliminatedLeftBreakpoint = 0        eliminatedRightBreakpoint = 0        breakleftStrip = 0        breakrightStrip = 0        if abs(self.genome[i - 1] - self.genome[i]) == 1:            breakleftStrip = -1        if abs(self.genome[j + 1] - self.genome[j]) == 1:            breakrightStrip = -1        # check if left breakpoint will be eliminated when reversing with        # indices i and j        if abs(self.genome[i - 1] - self.genome[j]) == 1:            eliminatedLeftBreakpoint = 1        # check if right breakpoint will be eliminated when reversing with        # indices i and j        if abs(self.genome[j + 1] - self.genome[i]) == 1:            eliminatedRightBreakpoint = 1        return eliminatedLeftBreakpoint + eliminatedRightBreakpoint + breakleftStrip + breakrightStrip    # Reverses a strip with begin index i and end index j in a given genome    def Reverse(self, i, j):        # the first piece of the genome        genomeStart = self.genome[0 : i]        # the to be mutated part in the genome        genomeMutation = self.genome[i : j + 1]        # the to be mutated part reversed        genomeMutated = list(reversed(genomeMutation))        # the ending part of the genome        genomeEnd = self.genome[j + 1 : len(self.genome)]        # return the mutated genome        return genomeStart + genomeMutated + genomeEnd        def MutateGreedyPoints(self, hillclimberBoolean, normalScoreFunction):        # initialize        bestScore = 0        bestMutation = []        bestLength = []        # optionList consists of (i, j, score)        optionList = []        for i in self.breakpointList:            for j in self.breakpointList:                if i != j and i < j and i >= 1 and j < len(self.genome) - 1:                    # execute every possible reverse and store the mutated genome                    # in temporaryGenome and calculate the difference in PHI, incurred by the current mutation,                    # that is: mutating strip (i,j)                    temporaryGenome = self.Reverse(i, j)                    deltaPHI = self.CalcDeltaPHI(i, j)                    # store the length of the piece that is being reversed                    if normalScoreFunction:                        mutationLength = j - i + 1                    else:                        mutationLength = float(float(1/2) * float((j - i + 1) ** 2))                    # formula on which we base what mutation to choose. currentScore should be as high as possible                    currentScore = deltaPHI / mutationLength                    # append current option to optionList                    optionList.append([i, j, currentScore])                    # check which mutation gives us the highest score                    if currentScore == bestScore:                        bestMutation.append(temporaryGenome)                        bestLength.append(mutationLength)                    elif currentScore > bestScore:                        bestLength = []                        bestMutation = []                        bestScore = currentScore                        bestMutation.append(temporaryGenome)                        bestLength.append(mutationLength)        if hillclimberBoolean == False:            return bestMutation[0], bestLength[0]        else:            # sort the optionlist on bestScore            optionList = sorted(optionList, key=lambda x: x[2])            optionList = list(reversed(optionList))            return optionList    # Looks for the best reversal possible with a set (i,j) and returns the mutate options     def MutateGreedy(self, prevI, prevJ):        # declare an array that stores the options there are to mutate a gene        # in the form ( i, j, deltaPHI, descending(T/F) )        mutateOptions = []        # set the best deltaPHI equal to 0        deltaPHIbest = 0        # execute all possible reverses, based on the possible Is and Js        for i in self.breakpointList:            for j in self.breakpointList:                if i != j and i < j and i >= 1 and j < len(self.genome) - 1:                    # execute every possible reverse and store the mutated genome                    # in temporaryGenome and calculate the difference in PHI, incurred by the current mutation,                    # that is: mutating strip (i,j)                    temporaryGenome = self.Reverse(i, j)                    deltaPHI = self.CalcDeltaPHI(i, j)                    # check whether deltaPHI is better/equally good as deltaPHIbest.                    # If so, append it to the mutateOptions. If not, no need to                    # store the option.                    if deltaPHI >= deltaPHIbest:                        if deltaPHI > deltaPHIbest:                            # set the new deltaPHIbest if it is larger then the old one                            deltaPHIbest = deltaPHI                            # clear the mutateOptions to keep it small, because if a new                            # deltaPHIbest has been found, we can throw away all old options                            mutateOptions = []                        # only consider deltaPHI = 2 and deltaPHI = 1, because for lower deltaPHIs                        # you don't want to do anything                        if deltaPHI == 2:                            # check whether a descending strip was found                            if temporaryGenome[i - 1] > temporaryGenome[i] or temporaryGenome[j] > temporaryGenome[j + 1]:                                # if descending AND deltaPHI = 2, we've found our best option already!                                return temporaryGenome, i, j, deltaPHI                            # if not descending, store the option and continue revising the                            # other options                            else:                                mutateOptions.append((i, j, deltaPHI, False))                        if deltaPHI == 1:                            # check whether a descending strip was found                            if temporaryGenome[i - 1] > temporaryGenome[i] or temporaryGenome[j] > temporaryGenome[j + 1]:                                # if so, store the option and continue revising the                                # other options                                mutateOptions.append((i, j, deltaPHI, True))                            # if not descending, store the option and continue revising the                            # other options                            else:                                mutateOptions.append((i, j, deltaPHI, False))                                                        if deltaPHI == 0:                            # check whether a descending strip was found                            if temporaryGenome[i - 1] > temporaryGenome[i] or temporaryGenome[j] > temporaryGenome[j + 1]:                                # if so, store the option and continue revising the                                # other options                                mutateOptions.append((i, j, deltaPHI, True))                            # if not descending, store the option and continue revising the                            # other options                            else:                                mutateOptions.append((i, j, deltaPHI, False))        # when all possible reverses are reviewed, let's see what we should do        # sort the mutateOptions array on deltaPHI. Using this sort method,        # the lowest deltaPHIs come first (minimum 1) with FALSE booleans for        # 'descending'.        mutateOptions = sorted(mutateOptions, key = lambda x: (x[2], x[3]))        # therefore, the array should be reversed        mutateOptions = list(reversed(mutateOptions))        if deltaPHIbest == 0:            randomIndex = random.randint(0, len(mutateOptions) - 1)            return self.Reverse(mutateOptions[randomIndex][0], mutateOptions[randomIndex][1]), mutateOptions[randomIndex][0], mutateOptions[randomIndex][1], mutateOptions[randomIndex][2]        # execute the first posssible option, because this is now the best one!        # (because descending options come first in the array)        # print("Hier zijn de mutateOptions: ", mutateOptions)        if prevI == mutateOptions[0][0] and prevJ == mutateOptions[0][1]:            return self.Reverse(mutateOptions[1][0], mutateOptions[1][1]), mutateOptions[1][0], mutateOptions[1][1], mutateOptions[1][2]        else:            return self.Reverse(mutateOptions[0][0], mutateOptions[0][1]), mutateOptions[0][0], mutateOptions[0][1], mutateOptions[0][2]    # makes option lists for the branch and bound algorithm and returns all options    def MutateBnB(self):        # declare arrays that store the breakpointPairs pairs that, when reversed,        # eliminate either 0, 1, or 2 breakpointPairs in the genome        eliminate_0_breakpoint = []        eliminate_1_breakpoint = []        eliminate_2_breakpoint = []        # execute all possible reverses, based on the possible Is and Js        for i in self.breakpointList:            for j in self.breakpointList:                if i != j and i < j and i >= 1 and j < len(self.genome) - 1:                    # execute every possible reverse and store the mutated genome                    # in temporaryGenome and calculate the difference in PHI, incurred by the current mutation,                    # that is: mutating strip (i,j)                    deltaPHI = self.CalcDeltaPHI(i, j)                    if deltaPHI == 0:                        eliminate_0_breakpoint.append((i,j))                    elif deltaPHI == 1:                        eliminate_1_breakpoint.append((i,j))                    elif deltaPHI == 2:                        eliminate_2_breakpoint.append((i,j))        return eliminate_2_breakpoint, eliminate_1_breakpoint, eliminate_0_breakpoint 